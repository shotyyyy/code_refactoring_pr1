#Рефакторинг программного кода
##Отчет по ПР№1

1. Неиспользуемый параметр

Влияние:

Засоряет интерфейс метода.

Сбивает с толку разработчиков (кажется, что параметр важен).

Увеличивает риск ошибок при поддержке.

Решение:

Применить Remove Parameter — убрать Response res из RequestHandler.Handle и всех вызовов.

2. Дублирование обработки API/страницы

Влияние:

Код повторяется, что затрудняет внесение изменений.

Любое исправление нужно делать в двух местах.

Решение:

Применить Extract Method и Replace Conditional with Parameter — объединить HandleApi и HandlePage в один метод HandleByKind.

3. Размытая ответственность метода Handle

Влияние:

Метод делает слишком много: хранение, извлечение, обработку, логирование.

Нарушается принцип единственной ответственности (SRP).

Трудно тестировать и изменять отдельные шаги.

Решение:

Применить Split Method и Extract Method — вынести шаги в отдельные методы (ExtractPayload, ProcessPayload, DetermineKind).

4. Слабая типизация в RequestStore

Влияние:

Потеря контроля над типами, хранится object.

Возможны ошибки времени выполнения.

Снижается понятность содержимого коллекции.

Решение:

Применить Introduce Generics (если возможно) либо Encapsulate Collection с проверками типов.

5. Непонятные названия переменных и функций

Влияние:

Создает проблемы с читаемостью кода.

Затрудняет поддержку и отладку.

Увеличивает время разработки.

Повышает риск неправильного использования переменных/функций.

Решение:

Применить Rename Variable/Method — заменить requests на requestStore, value на payload, result на processed.

6. Неполное маскирование секретов

Влияние:

Логи могут содержать пароли в URI.

Риск утечек данных в продакшене.

Решение:

Применить Extract Method и улучшить регэксп — поддержать как Password=..., так и scheme://user:pass@host.

7. Ненадёжная реализация DeepCopy

Влияние:

Возможен NullReferenceException.

При ошибке сериализации программа может упасть.

Решение:

Применить Introduce Guard Clauses и безопасное преобразование — возвращать исходный объект при ошибке.

8. Хрупкость выбора типа БД

Влияние:

Новые типы БД добавляются через “if/else” → растёт сложность.

Сложнее расширять систему.

Решение:

Применить Replace Conditional with Switch Expression.

9. Игнорирование настроек уровня логирования

Влияние:

Конфигурация ServiceConfig.LogLevel никак не влияет на вывод.

Несогласованность между конфигом и поведением.

Решение:

Применить Introduce Parameter Object — учесть LogLevel при настройке Logger.

10. Возврат object? в арифметике

Влияние:

Неочевидный контракт метода.

Требует явных приведений и дополнительных проверок.

Решение:

Применить Encapsulate Return Value — по возможности уточнить тип (например, double?), либо добавить проверку и документацию.
